= Zicmobase Extension, Version 0.1
:sectnums:
:toc:

== Introduction

The Zicmobase extension adds a base set of _cache management operation_ (or 
_CMO_) instructions and CSRs to the RISC-V architecture.
The base extension includes several classes of instructions that operate on 
cache blocks:

* A set of cache block management instructions, i.e. `CBO.INVAL.EA`,
  `CBO.CLEAN.EA`, and `CBO.FLUSH.EA`
* A cache block write instruction, i.e. `CBO.ZERO.EA`
* A set of cache block hint instructions, i.e. `PREFETCH.R.EA`,
  `PREFETCH.W.EA`, `PREFETCH.I.EA`, and `DEMOTE.EA`
* A cache block size discovery instruction, i.e. `CBO.SIZE` (TBD)

The execution of these instructions in various privilege modes is controlled by 
a set of CSRs.
In addition, this specification introduces architectural abstractions for 
caches and system topologies to support portable software across various system 
designs.

=== Goals

* Introduce an architectural abstraction of caches and system topology
* Define instructions that operate on the abstract cache and system topology
* Specify the interactions of CBOs with the RVWMO memory ordering model
* Support various software use-cases such as software-managed cache coherence
  and non-coherent I/O
* Allow execution of cache management operations in lower privilege modes

== Overview

=== Caches in RISC-V

Caches in RISC-V serve the same purpose as in other architectures: to reduce 
average memory latency by buffering copies of data values close to a system 
agent.
A cached copy of data is known as a _cache block_, which is a naturally aligned 
power-of-two (NAPOT) set of an _implementation-defined_ number of bytes, 
corresponding to a similarly sized and aligned set of memory locations.
A system may make multiple copies of a cache block, and these copies may be 
transferred between various caches and memory.

*_FIXME:_* types of cache blocks?

A cache consists of a set of cache blocks, organized in an 
_implementation-defined_ manner.
RISC-V defines three types of caches: A _private cache_ is accessed by a single 
hart or device, while a _shared cache_ is accessed by a set of harts and 
devices.
In addition, a _memory cache_ is localized to a main memory region or an I/O 
device region and is effectively "invisible" to the system agents that access 
memory.
The base set of cache management operations operates on private and shared 
caches only and does not operate on memory caches.

==== Cache Block States

A cache block may be in one of three states:

* Invalid - a copy of the cache block is not present in the cache
* Unmodified - a copy of the cache block is present in the cache and has _not_
  been explicitly written by a system agent
* Modified - a copy of the cache block is present in the cache and has been
  explicitly written by a system agent

A cache tracks the unmodified or modified state of a cache block while the 
block is present in the cache.
A transfer of a cache block to or from a cache may also communicate the state 
of the cache block via _implementation-defined_ mechanisms, typically 
transactions in a bus protocol or cache coherence protocol.

A transition from invalid to either unmodified or modified occurs when a cache 
allocates a cache block, resulting in a transfer of the block to the cache from 
another cache or memory.
To the extent allowed by the base and privileged architectures, a cache may 
allocate a cache block for any physical address at any time for any reason.
The cache block is allocated in either the unmodified or modified state 
depending on whether an unmodified cache block or a modified cache block, 
respectively, was transferred to the cache and depending on any 
_implementation-defined_ policies of the cache, e.g. write-through or 
write-back.

A transition from unmodified to modified occurs whenever a system agent 
executes an instruction, e.g. a store instruction, or performs an operation, 
e.g. a page table entry write, that writes to a cache block that has been 
transferred to the cache.
To cause the transition, the instruction or operation only needs to be 
classified as a data write that _may_ change the data values in the cache 
block; the data write is _not required_ to change the data values.

A transition from either unmodified or modified to invalid occurs when a cache 
deallocates the cache block, possibly resulting in a transfer of the block from 
the cache to another cache or memory.
If the cache block is unmodified, the cache may transfer the unmodified block 
to another cache or memory, but if the cache block is modified, the cache 
_must_ transfer the modified block to another cache or memory.
A cache may deallocate a cache block at any time for any reason.

Cache management operations also cause cache blocks to change state:

* An _invalidate operation_ on either a modified or unmodified cache block
  forces a transition to invalid without a transfer of the block from the cache
* A _clean operation_ on a modified cache block forces a transition to
  unmodified, resulting in a transfer of the modified block from the cache
* A _flush operation_ on a modified cache block forces a transition to invalid,
  resulting in a transfer of the modified block from the cache; a flush
  operation on an unmodified cache block forces a transition to invalid

The above operations have no effect on an invalid cache block.
Additionally, clean operations on an unmodified cache block have no effect, and 
flush operations on an unmodified cache block do _not_ result in a transfer of 
the unmodified block from the cache.

The transfer of a cache block to a cache may result in a read from memory, 
while the transfer of a cache block from a cache may result in a write to 
memory.
An unmodified cache block _must not_ be written to memory.

==== Cache Coherence

*_FIXME:_* Sort out the relationship between PoCs and domains

The architecture does not require hardware to keep multiple cached copies of 
data coherent with respect to each other; however, a system may implement a 
_cache coherence_ mechanism in hardware.
The set of caches kept coherent by such a mechanism is called a 
_coherence domain_.
A system may have multiple coherence domains, and a given coherence domain may 
or may not keep the copies of data in its caches coherent with the copy of data 
in memory.

****
_One of the primary use-cases for the cache management operations is to 
implement cache coherence in software._
****

A hardware cache coherence mechanism may add additional cache states and may 
cause additional cache block state transitions.
The effects of a hardware cache coherence mechanism on cache block state is 
beyond the scope of this specification.

==== Memory

Consistent with the base and privileged RISC-V architecture, every physical 
address corresponds to a location in memory, either in a main memory region, an 
I/O device region, or a vacant region.
The memory locations corresponding to a cache block are known as the _backing 
storage_ for that block.
In addition, a memory cache may serve as a proxy for the actual memory 
locations.

==== System Agents

_System agents_ perform memory accesses.
A system agent may be a hart or an I/O device (shortened to _device_ in this 
specification).

==== System Topology

*_FIXME:_* Sort out the relationship between PoCs and domains

A memory access follows a _path_ from a system agent to a memory location, and 
on that path, a memory access may access one or more private or shared caches.
A path is determined by the following:

* The type of operation
* The physical address of the operation
* The system agent performing the operation
* The memory attributes associated with the operation

Paths converge at a _point of convergence_, or _PoC_, which designates the 
point at which a set of memory accesses is logically ordered.
Once ordered by a PoC, a memory access in the set cannot be reordered with 
respect to other memory accesses in the set, and the set of memory accesses 
shares the remainder of the path to the memory location.

****
_A PoC may be represented, for example, by a single physical entity, such as an 
arbiter, or a distributed logical process, such as a cache coherence protocol, 
as long as the order of memory accesses is preserved once established._
****

****
_The pertinent memory attributes are typically cacheability and coherence; 
however, other memory attributes may affect the system behavior in such a way 
that the set of memory accesses ordered by PoC changes._
****

This extension defines several PoCs. The fundamental PoC for a given physical 
address is the _point of convergence for memory_, or _PoC-memory_, which is the 
PoC where all paths for that physical address converge, independent of 
operation, system agent, or memory attributes.

****
_The PoC-memory conceptually represents the point at which memory accesses from 
all system agents that can access a memory location via the same physical 
address are ordered._
_The architecture does not prohibit system agents from accessing a memory 
location without passing through the PoC-memory, nor does the architecture 
prohibit caches beyond the PoC-memory._
_However, in such a system, software cannot expect the architectural cache 
operations to have the desired effects with respect to those system agents or 
caches._
****

****
_Additional system topology beyond the PoC-memory may be specified in future 
extensions._
_For example, various points of persistence may be defined to support different 
classes of storage._
****

*_FIXME:_* Other PoCs?

=== FIXME: Memory Ordering

From a memory ordering perspective, a memory access resulting from a cache operation instruction is considered to be a load operation or a store operation in the RVWMO memory ordering model depending on the instruction:

* Cache block management instructions are generally considered to be store operations; however, like AMOs, the store operations generated by these instructions must be ordered with respect to subsequent loads to overlapping addresses in program order
* Cache block write instructions are considered to be store operations
* Cache block hint instructions are considered to be load operations

Cache management operations are ordered with respect to other load operations, store operations, and cache management operations as specified by RVWMO, subject to any additional constraints defined above.
In particular, overlapping address orderings are preserved (with the additional constraints defined above), while a `FENCE` instruction may be used to order cache management operations with respect to operations to non-overlapping addresses.
The other RVWMO ordering rules apply as well.

For a cache block management instruction, the _effects_ of the resulting operation are ordered with respect to any other required operations.
In other words, such a cache operation is considered to be ordered once the operation is performed with respect to the required system agents.

****
_The existing `FENCE` instruction is sufficient to order the cache management operations in the base extension._
_In future extensions, an additional fence instruction may be required to determine when certain cache management operations are complete._
****

=== Traps

==== Illegal Instruction and Virtual Instruction Exceptions

Cache block management instructions and cache block write instructions may take 
an illegal instruction exception depending on the _current privilege mode_ and 
the state of the CMO control registers described <<_csrs,below>>.
The current privilege mode refers to the privilege mode of the hart at the time 
the instruction is executed.

Cache block hint instructions do _not_ take illegal instruction exceptions.

Additionally, CMO instructions do _not_ take virtual instruction exceptions.

==== Page Fault and Guest-Page Fault Exceptions

During address translation, CMO instructions may take a page fault depending on 
the type of instruction, the _effective privilege mode_, and the permissions 
granted by the page table entry (PTE).
The effective privilege mode is either the current privilege mode (if 
`mstatus.MPRV=0`) or the privilege mode determined by `mstatus.MPV` and 
`mstatus.MPP` (if `mstatus.MPRV=1`).
If two-stage address translation is enabled, CMO instructions may also take a 
guest-page fault.

Cache block management instructions require a valid translation (`V=1`) and 
either read (`R=1`) or execute (`X=1`) permission and, if applicable, user 
access (`U=1`) in the effective privilege mode.
If these conditions are _not_ met, the instruction takes a store/AMO page fault 
exception.
In addition, `CBO.INVAL.EA` instructions may take a store/AMO page fault 
exception depending on the state of the CMO control registers described 
<<_csrs,below>> and whether the access has been granted write permission by the 
PTE.

Cache block write instructions require a valid translation (`V=1`) and write 
(`W=1`) permission and, if applicable, user access (`U=1`) in the effective 
privilege mode.
If these conditions are _not_ met, the instruction takes a store/AMO page fault 
exception.

If G-stage address translation is enabled, the above instructions take a 
store/AMO guest-page fault if the G-stage PTE does _not_ allow the access.

Cache block hint instructions require a valid translation (`V=1`) and either 
read (`R=1`) or execute (`X=1`) permission and, if applicable, user access 
(`U=1`) in the effective privilege mode.
If these conditions are _not_ met, however, the instruction does _not_ take a 
page fault or guest-page fault exception and retires without accessing memory.

===== Effect of other `xstatus` bits

The `mstatus.MXR` bit (also `sstatus.MXR`) and the `vsstatus.MXR` bit do _not_ 
affect the execution of CMO instructions.

The `mstatus.SUM` bit (also `sstatus.SUM`) and the `vsstatus.SUM` bit allow 
S/HS-mode and VS-mode access, respectively, to pages marked with `U=1`, but 
otherwise, these bits do _not_ affect the execution of CMO instructions.

==== Access Fault Exception

During address translation, CMO instructions may take an access fault exception 
if an implicit table walk access encounters a PMP or PMA violation.
Otherwise, assuming a valid translation, CMO instructions may also take an 
access fault exception depending on the type of instruction, the effective 
privilege mode, and the permissions granted by the physical memory protection 
(PMP) unit and the physical memory attributes (PMAs).

****
_For now, we assume two things about PMAs:_

. _PMAs are the same for all physical addresses in a cache block_
. _Memory that can be cached cannot be write-only_
****

Read (`R`), write (`W`), and execute (`X`) permissions are granted by the PMP 
and the PMAs.
The PMP may grant different permissions to different physical addresses in a 
cache block; however, the PMAs for a cache block _must_ be the same for _all_ 
physical addresses in the cache block and read permission _must_ be granted if 
write permission has been granted.
If these PMA constraints are not met, the behavior of CMO instruction is 
UNSPECIFIED.

For the purposes of access fault determination, _joint permission_ is granted 
for a given physical address when the same access type is allowed by both the 
PMP and the PMAs for that physical address.
For example, joint read permission implies that both the PMP and PMAs allow 
a read access.
In addition, for a given cache block, _partial joint write permission_ implies 
that joint write permission has been granted to only _some_ of the physical 
addresses in the cache block, while _full joint write permission_ implies that 
joint write permission has been granted to _all_ physical addresses in the 
cache block.

Cache block management instructions require either joint read or joint execute 
permission for _all_ accessed physical addresses.
If this condition is _not_ met, the instruction takes a store/AMO access fault 
exception.
In addition, `CBO.INVAL.EA` instructions may take a store/AMO access fault 
exception depending on the state of the CMO control registers described 
<<_csrs,below>> and whether the access has been granted partial joint write 
permission by the PMP and PMAs.

Cache block write instructions require full joint write permission.
If this condition is _not_ met, the instruction takes a store/AMO access fault 
exception.

Cache block hint instructions require either joint read or joint execute 
permission for _all_ accessed physical addresses.
If this condition is _not_ met, however, the instruction does _not_ take an 
access fault exception and retires without accessing memory.

==== Address Misaligned Exception

CMO instructions do _not_ generate address misaligned exceptions.

==== Address Breakpoint Exception

Whether CMO instructions generate address breakpoint exceptions is
_implementation-defined_.

== Formats

=== CSRs

Four CSRs control execution of CMO instructions:

* `mcmocontrol`
* `scmocontrol`
* `hcmocontrol`
* `vscmocontrol`

****
`scmocontrol` _and_ `vscmocontrol` _are both required in order to distinguish 
CMO execution behavior when the effective privilege mode is U-mode or VU-mode, 
respectively._
****

Each `xcmocontrol` register has the following generic format:

.Generic Format for xcmocontrol CSRs
[cols="^1,^1,1a"]
[%autowidth]
|===
| Bits    | Name     | Description

| [0]     | `CBME`   | Cache Block Management instruction Enable

Determines the behavior of a cache block management instruction (i.e. 
`CBO.INVAL.EA`, `CBO.CLEAN.EA`, or `CBO.FLUSH.EA`) when the instruction is 
executed in _privilege_mode_.

* `0`: The instruction takes an illegal instruction exception
* `1`: The instruction is executed

| [1]     | `CBWE`   | Cache Block Write instruction Enable

Determines the behavior of a cache block write instruction (i.e. `CBO.ZERO.EA`) 
when the instruction is executed in _privilege_mode_.

* `0`: The instruction takes an illegal instruction exception
* `1`: The instruction is executed

| [7:2]   | _Rsvd_   | _Reserved_

| [8]     | `INVW0I` | `CBO.INVAL.EA` access without write permission performs 
an Invalidate operation

Determines the operation performed by a `CBO.INVAL.EA` instruction when the 
resulting access _has not been_ granted write permission in the effective 
privilege mode (_Wx_=`W0`) and when the instruction does _not_ raise an 
exception:

* `0`: The instruction performs a flush operation
* `1`: The instruction performs an invalidate operation

| [9]     | `INVW0E` | `CBO.INVAL.EA` access without write permission Enable

Determines the behavior of a `CBO.INVAL.EA` instruction when a 
_protection_mechanism_ is enabled and the resulting access _has not been_ 
granted write permission in the effective privilege mode (_Wx_=`W0`):

* `0`: The instruction takes an exception (page fault, guest-page fault, or 
  access fault depending on the CSR)
* `1`: The instruction performs an operation based on `INVW0I`

| [10]    | `INVW1I` | `CBO.INVAL.EA` access with write permission performs an 
Invalidate operation

Determines the operation performed by a `CBO.INVAL.EA` instruction when the 
resulting access _has been_ granted write permission in the effective privilege 
mode (_Wx_=`W1`) and when the instruction does _not_ raise an exception:

* `0`: The instruction performs a flush operation
* `1`: The instruction performs an invalidate operation

| [11]    | `INVW1E` | `CBO.INVAL.EA` access without write permission Enable

Determines the behavior of a `CBO.INVAL.EA` instruction when a 
_protection_mechanism_ is enabled and the resulting access _has been_ granted 
write permission in the effective privilege mode (_Wx_=`W1`):

* `0`: The instruction takes an exception (page fault, guest-page fault, or 
  access fault depending on the CSR)
* `1`: The instruction performs an operation based on `INVW0I`

|===

Each `xcmocontrol` register is WARL, where CSR reads return the behaviors 
supported by the implementation.

* 000x - trap W1; trap W0; flush disable
* 00x0 - trap W1; trap W0; flush disable
* 0011 - trap W1; trap W0; inval disable

* 0100 - trap W1; flush W0; flush disable
* 0101 - trap W1; inval W0; flush disable
* 0110 - trap W1; flush W0; flush disable
* 0111 - trap W1; inval W0; inval disable

* 1000 - flush W1; trap W0; flush disable
* 1001 - inval W1; trap W0; flush disable
* 1010 - flush W1; trap W0; flush disable
* 1011 - inval W1; trap W0; inval disable



The following subsections detail how the `xcmocontrol` CSRs govern the 
execution of CMO instructions.

===== Determining Illegal Instruction Exceptions

The descriptions for the `CBME` and `CBZE` bits in the `xcmocontrol` registers 
include a _privilege_mode_ parameter that corresponds to the privilege modes 
controlled by a given CSR. Each CSR defines this parameter as follows:

* For `mcmocontrol`, _privilege_mode_ corresponds to S/HS-mode, U-mode, 
  VS-mode, and VU-mode
* For `scmocontrol`, _privilege_mode_ corresponds to U-mode
* For `hcmocontrol`, _privilege_mode_ corresponds to VS-mode and VU-mode
* For `vscmocontrol`, _privilege_mode_ corresponds to VU-mode

Depending on the _current privilege mode_, a cache block management instruction 
takes an illegal instruction exception based on the `CBME` bits:

* M-mode: +
  `FALSE` (cache block management instructions never take illegal instruction 
  exceptions)
* S/HS-mode: +
  `!mcmocontrol.CBME`
* U-mode: +
  `!mcmocontrol.CBME || !scmocontrol.CBME`
* VS-mode: +
  `!mcmocontrol.CBME || !hcmocontrol.CBME`
* VU-mode: +
  `!mcmocontrol.CBME || !hcmocontrol.CBME || !vscmocontrol.CBME`

Depending on the _current privilege mode_, a cache block write instruction 
takes an illegal instruction exception based on the `CBWE` bits:

* M-mode: +
  `FALSE` (cache block write instructions never take illegal instruction 
  exceptions)
* S/HS-mode: +
  `!mcmocontrol.CBWE`
* U-mode: +
  `!mcmocontrol.CBWE || !scmocontrol.CBWE`
* VS-mode: +
  `!mcmocontrol.CBWE || !hcmocontrol.CBWE`
* VU-mode: +
  `!mcmocontrol.CBWE || !hcmocontrol.CBWE || !vscmocontrol.CBWE`

Otherwise, the above instructions are executed in the _current privilege mode_.

===== Determining Page Fault, Guest-Page Fault, and Access Fault Exceptions

The descriptions for the `INVWxE` and `INVWxI` bits in the `xcmocontrol` 
registers include a _protection_mechanism_ parameter that corresponds to the 
protection mechanism that determines write permission for an access and a 
_Wx_ parameter that represents whether write permission has been granted (`W1`) 
or not (`W0`).
Each CSR defines these as follows:

* For `mcmocontrol`, _protection_mechanism_ corresponds to the PMP and PMAs 
  and _Wx_ corresponds to whether partial joint write permission has been 
  granted by the PMP and PMAs
* For `scmocontrol`, _protection_mechanism_ corresponds to the `satp` page 
  table and _Wx_ corresponds to whether write permission has been granted by 
  the leaf PTE `W` bit
* For `hcmocontrol`, _protection_mechanism_ corresponds to the `hgatp` page 
  table and _Wx_ corresponds to whether write permission has been granted by 
  the leaf PTE `W` bit
* For `vscmocontrol`, _protection_mechanism_ corresponds to the `vsatp` page 
  table and _Wx_ corresponds to whether write permission has been granted by 
  the leaf PTE `W` bit

For each CSR, the resulting `INVWxE` value is determined by the designated 
_protection_mechanism_, which selects the `INVW0E` bit if _Wx_=`W0` or the 
`INVW1E` bit if _Wx_=`W1`.
Depending on the _effective privilege mode_, a `CBO.INVAL.EA` instruction takes 
the following types of traps based on the `INVWxE` values:

* M-mode:
  **  _N/A_ (`CBO.INVAL.EA` never faults due to the CMO control registers)
* S/HS-mode:
  ** Access fault: +
    `!(mcmocontrol.INVWxE)`
* U-mode:
  ** Page fault: +
    `!(scmocontrol.INVWxE || satp.MODE==Bare)`
  ** Access fault: +
    `(scmocontrol.INVWxE || satp.MODE==Bare) &&` +
    `!(mcmocontrol.INVWxE)`
* VS-mode:
  ** Guest-page fault: +
    `!(hcmocontrol.INVWxE || hgatp.MODE==Bare)`
  ** Access fault: +
    `(hcmocontrol.INVWxE || hgatp.MODE==Bare) &&` +
    `!(mcmocontrol.INVWxE)`
* VU-mode:
  ** Page fault: +
    `!(vscmocontrol.INVWxE || vsatp.MODE==Bare)`
  ** Guest-page fault: +
    `(vscmocontrol.INVWxE || vsatp.MODE==Bare) &&` +
    `!(hcmocontrol.INVWxE || hgatp.MODE==Bare)`
  ** Access fault: +
    `(vscmocontrol.INVWxE || vsatp.MODE==Bare) &&` +
    `(hcmocontrol.INVWxE || hgatp.MODE==Bare) &&` +
    `!(mcmocontrol.INVWxE)`

****
_The above exception priorities reflect the architected exception priorities in 
the privileged architecture specification._
****

For each CSR, the resulting `INVWxI` value is determined by the designated 
_protection_mechanism_, which selects the `INVW0I` bit if _Wx_=`W0` or the 
`INVW1I` bit if _Wx_=`W1`, if that protection mechanism is enabled.
If the protection mechanism is disabled, the `INVWxI` value is the logical AND 
of the `INVW0I` bit and the `INVW1I` bit, i.e. both bits _must_ be set to 
perform an invalidate operation.
Assuming that no exception arises and depending on the 
_effective privilege mode_, a `CBO.INVAL.EA` instruction performs the following 
operations based on the `INVWxI` values:

* M-mode:
  ** Flush: +
  `FALSE` (`CBO.INVAL.EA` never performs a flush operation)
  ** Invalidate: +
  `TRUE` (`CBO.INVAL.EA` always performs an invalidate operation)
* S-mode:
  ** Flush: +
    `!(mcmocontrol.INVWxI)`
  ** Invalidate: +
    `(mcmocontrol.INVWxI)`
* U-mode:
  ** Flush: +
    `!(scmocontrol.INVWxI && mcmocontrol.INVWxI)`
  ** Invalidate: +
    `(scmocontrol.INVWxI && mcmocontrol.INVWxI)`
* VS-mode:
  ** Flush: +
    `!(hcmocontrol.INVWxI && mcmocontrol.INVWxI)`
  ** Invalidate: +
    `(hcmocontrol.INVWxI && mcmocontrol.INVWxI)`
* VU-mode:
  ** Flush: +
    `!(vscmocontrol.INVWxI && hcmocontrol.INVWxI && mcmocontrol.INVWxI)`
  ** Invalidate: +
    `(vscmocontrol.INVWxI && hcmocontrol.INVWxI && mcmocontrol.INVWxI)`



'''
[.text-center]
*FIXME BEYOND HERE*

'''


----
* M-mode:
  **  _N/A_ (CBO.INVAL.EA never faults due to the CMO control registers)
* S/HS-mode:
  ** Access fault: +
    `!(mcmocontrol.INVWxE)`
* U-mode:
  ** Access fault: +
    `!(mcmocontrol.INVWxE)`
  ** Page fault: +
    `(mcmocontrol.INVWxE) &&` +
    `!(scmocontrol.INVWxE || satp.MODE==Bare)`
* VS-mode:
  ** Access fault: +
    `(!mcmocontrol.INVWxE)`
  ** Guest-page fault: +
    `(mcmocontrol.INVWxE) &&` +
    `!(hcmocontrol.INVWxE || hgatp.MODE==Bare)`
* VU-mode:
  ** Access fault: +
    `!(mcmocontrol.INVWxE)`
  ** Guest-page fault: +
    `(mcmocontrol.INVWxE) &&` +
    `!(hcmocontrol.INVWxE || hgatp.MODE==Bare)`
  ** Page fault: +
    `(mcmocontrol.INVWxE) &&` +
    `(hcmocontrol.INVWxE || hgatp.MODE==Bare) &&` +
    `!(vscmocontrol.INVWxE || vsatp.MODE==Bare)`






| [9:8]   | `INVW0`  | CBO.INVAL.EA access without write permission (`_Wx_=0`).

Determines the behavior of a CBO.INVAL.EA instruction when the corresponding 
access does _not_ have write permission in the effective privilege mode:

* `0`: Execution results in an exception (page fault, guest-page fault, or 
  access fault) [trap]
* `1`: _Reserved_ (aliases to `0`)
* `2`: Execution performs a flush operation [flush]
* `3`: Execution performs an invalidate operation [invalidate]

| [11:10] | `INVW1`  | CBO.INVAL.EA access with write permission (`_Wx_=1`).

Determines the behavior of a CBO.INVAL.EA instruction when the corresponding 
access has write permission in the effective privilege mode:

* `0`: Execution results in an exception (page fault, guest-page fault, or 
  access fault depending on the CSR) [trap]
* `1`: _Reserved_ (aliases to `0`)
* `2`: Execution performs a flush operation [flush]
* `3`: Execution performs an invalidate operation [invalidate]

|         |          |
----


== Instructions

=== Cache Block Management Instructions

These take an effective address in _rs1_

_level_ is encoded in the instruction

==== `CBO.INVAL.EA`

INVAL commentary: INVAL may expose stale data values in memory, resulting in a potential security hole if a given physical address is reused for less privileged software that has invalidation enabled.
To avoid such holes, privileged software must either prevent invalidation by disabling it or preemptively perform a flush operation prior to granting access to the less privileged software.

==== `CBO.CLEAN.EA`

==== `CBO.FLUSH.EA`


=== Cache Block Write Instruction

This takes an effective address in _rs1_

==== `CBO.ZERO.EA`

Byte atomic

=== Cache Block Hint Instructions

These take an effective address in _rs1_ or an effective address from _rs1 + imm12_

==== `PREFETCH.R.EA`

==== `PREFETCH.W.EA`

==== `PREFETCH.I.EA`

==== `DEMOTE.EA`

=== Cache Block Discovery Instruction

==== `CBO.SIZE`


== Opcode Map
